{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"about/","title":"Quoque parentis fessusque agendum","text":""},{"location":"about/#et-amorem-crate-et-uno-torique","title":"Et amorem crate et uno torique","text":"<p>Lorem markdownum senex. Arte nocte conubia altissimus Venus. Femina inhaerebat et aevi relicta mea nati caputque rotae promissas. Mortis dicitur videbat mihi: terga motu enim mollibus frater. Volat quo tellus caputque vulnere venit semina, at poena cur inpulit fumos, pendens?</p> <pre><code>if (cropBalancing(25, burnCookieSerp, matrixCyberspaceMinicomputer)) {\n    rwCross = zero + dvi_up_waveform(peripheralProcessor,\n            romCompactFirmware, dimm);\n    clusterThinNetmask(aix_flash_regular);\n}\ncloud_platform += dram;\nmirroredPage += flowchart_favorites;\n</code></pre> <p>Verba omnia Pallas Thaumantias vadit. Nempe di stridore Gorgonis. Perenni necis pectore et aliquid eripiunt speciosaque viri, sua hunc ille curarum. Diluvio reicere, Troiana, nocendi praesentia lacus et ille in et nuper vox genitor tibi non, tunc mediamque. Exspirare Bacchus bibulis famuli Aesonides viventi flectit dat naiadum occupat, relinquit sonat.</p>"},{"location":"about/#gerunt-est-quibus-perluit-traderet-arvo-meritis","title":"Gerunt est quibus perluit traderet arvo meritis","text":"<p>Et abstulit, visa in illa arbitrium infans sollemni comes manusque quattuor paravi venit numen non, disiectisque. Tanta quorum fuit, spe cupit mox: natalis et dapes sinumque. Voce latebra tangeris ausim parva cum, rege meis in dumque veniat.</p> <ol> <li>In canum</li> <li>Quamque certe certa materiem et Hymenaeon illi</li> <li>Constitit parma Euphrates morbo</li> <li>Animumque nostris mente adversa tenebroso adhibete tum</li> <li>Inquit figuras sustulit casuraque vindicis</li> <li>Vocat ea ferebat sanguineam heu</li> </ol> <p>Cui ignarus, has fraterque, propensum feras Hersilien senex surge, qui alimenta cur versus fuerant Perseus, circueunt. Canaeque nomine, in et, fuit sub sed fulvis tura enim exclamo colunt infringat diuque, imae haud sola. Etiam lacusque cum faciem inmanibus florentis et Argolis orbis fraternaeque dixit nostros tecti comae. Cadentum quod novae moenia et deorum, non tenens, pererrant hiems expetit accensae, aura caelo susceptaque.</p> <p>Dentes Saturnia rauca loco bello pulsa quis reluxit alta, carpitur edax, huc nisi tegebat. Sit illa est mutua tradidit adpulit, nisi, conata tibi suos congreditur modo daedalus nocendi sequiturque cupit cecidisti et. Simplex potentia oculis.</p>"},{"location":"Features/Devices%20%26%20Cabling/","title":"Devices &amp; Cabling","text":"<p>At its heart, NetMon is a tool for modeling your network infrastructure, and the device object is pivotal to that function. A device can be any piece of physical hardware installed within your network, such as server, router, or switch, and may optionally be mounted within a rack. Within each device, resources such as network interfaces and console ports are modeled as discrete components, which may optionally be grouped into modules.</p> <p>NetMon uses device types to represent unique real-world device models. This allows a user to define a device type and all its components once, and easily replicate an unlimited number of device instances from it.</p>"},{"location":"Features/Devices%20%26%20Cabling/#manufacturers","title":"Manufacturers","text":"<p>A manufacturer generally represents an organization which produces hardware devices. These can be defined by users, however they should represent an actual entity rather than some abstract idea.</p>"},{"location":"Features/Devices%20%26%20Cabling/#device-types","title":"Device Types","text":"<p>A device type represents a unique combination of manufacturer and hardware model which maps to discrete make and model of device which exists in the real world. Each device type typically has a number of components created on it, representing network interfaces, device bays, and so on. New devices of this type can then be created in NetMon, and any associated components will be automatically replicated from the device type. This avoids needing to tediously recreate components for each device as it is added in NetMon.</p> <p>The Device Type Library</p> <p>While users are always free to create their own device types in NetMon, many find it convenient to draw from our\u00a0community library\u00a0of pre-defined device types. This is possible because a particular make and model of device is applicable universally and never changes.</p> <p>All the following can be modeled as components:</p> <ul> <li>Interfaces</li> <li>Console ports</li> <li>Console server ports</li> <li>Power ports</li> <li>Power outlets</li> <li>Pass-through ports (front and rear)</li> <li>Module bays (which house modules)</li> <li>Device bays (which house child devices)</li> </ul> <p>For example, a Juniper EX4300-48T device type might have the following component templates defined:</p> <ul> <li>One template for a console port (\"Console\")</li> <li>Two templates for power ports (\"PSU0\" and \"PSU1\")</li> <li>48 templates for 1GE interfaces (\"ge-0/0/0\" through \"ge-0/0/47\")</li> <li>Four templates for 10GE interfaces (\"xe-0/2/0\" through \"xe-0/2/3\")</li> </ul> <p>Once component templates have been created, every new device that you create as an instance of this type will automatically be assigned each of the components listed above.</p> <p>Component Instantiation is not Retroactive</p> <p>The instantiation of components from a device type definition occurs only at the time of device creation. If you modify the components assigned to a device type, it will not affect devices which have already been created. This guards against any inadvertent changes to existing devices. However, you always have the option of adding, modifying, or deleting components on existing devices. (These changes can easily be applied to multiple devices at once using the bulk operations available in the UI.)</p>"},{"location":"Features/Devices%20%26%20Cabling/#devices","title":"Devices","text":"<p>Whereas a device type defines the make and model of a device, a device itself represents an actual piece of installed hardware somewhere in the real world. A device can be installed at a particular position within an equipment rack, or simply associated with a site (and optionally with a location within that site).</p> <p>Each device can have an operational status, functional role, and software platform assigned. Device components are instantiated automatically from the assigned device type upon creation.</p>"},{"location":"Features/Devices%20%26%20Cabling/#virtual-chassis","title":"Virtual Chassis","text":"<p>Sometimes it is necessary to model a set of physical devices as sharing a single management plane. Perhaps the most common example of such a scenario is stackable switches. These can be modeled as virtual chassis in NetMon, with one device acting as the chassis master and the rest as members. All components of member devices will appear on the master.</p>"},{"location":"Features/Devices%20%26%20Cabling/#virtual-device-contexts","title":"Virtual Device Contexts","text":"<p>A virtual device context (VDC) is a logical partition within a device. Each VDC operates autonomously but shares a common pool of resources. Each interface can be assigned to one or more VDCs on its device.</p>"},{"location":"Features/Devices%20%26%20Cabling/#module-types-modules","title":"Module Types &amp; Modules","text":"<p>Much like device types and devices, module types can instantiate discrete modules, which are hardware components installed within devices. Modules often have their own child components, which become available to the parent device. For example, when modeling a chassis-based switch with multiple line cards in NetMon, the chassis would be created (from a device type) as a device, and each of its line cards would be instantiated from a module type as a module installed in one of the device's module bays.</p> <p>Device Bays vs. Module Bays</p> <p>What's the difference between device bays and module bays? Device bays are appropriate when the installed hardware has its own management plane, isolated from the parent device. A common example is a blade server chassis in which the blades share power but operate independently. In contrast, a module bay holds a module which does\u00a0not\u00a0operate independently of its parent device, as with the chassis switch line card example mentioned above.</p> <p>One especially nice feature of modules is that templated components can be automatically renamed according to the module bay into which the parent module is installed. For example, if we create a module type with interfaces named\u00a0<code>Gi{module}/0/1-48</code>\u00a0and install a module of this type into module bay 7 of a device, NetMon will create interfaces named\u00a0<code>Gi7/0/1-48</code>.</p>"},{"location":"Features/Devices%20%26%20Cabling/#cables","title":"Cables","text":"<p>NetMon models cables as connections among certain types of device components and other objects. Each cable can be assigned a type, color, length, and label. NetMon will enforce basic sanity checks to prevent invalid connections. (For example, a network interface cannot be connected to a power outlet.)</p> <p>Either end of a cable may terminate to multiple objects of the same type. For example, a network interface can be connected via a fiber optic cable to two discrete ports on a patch panel (each port attaching to an individual fiber strand in the patch cable).</p>"},{"location":"Features/Feature3/","title":"Heading 1","text":""},{"location":"Features/Feature3/#heading-2","title":"Heading 2","text":"<p>This is a paragraph. This is a paragraph.This is a paragraph.This is a paragraph.This is a paragraph.This is a paragraph.This is a paragraph.This is a paragraph.This is a paragraph.This is a paragraph. Please see IP Address Management for further details.</p>"},{"location":"Features/Feature3/#another-heading-2","title":"Another Heading 2","text":"<p>This is another paragraph. This is another paragraph.This is another paragraph.This is another paragraph.This is another paragraph.This is another paragraph.This is another paragraph.This is another paragraph.This is another paragraph. Please see Devices for more details.</p>"},{"location":"Features/IPAM/","title":"IP Address Management","text":"<p>IP address management (IPAM) is one of NetMon's core features. It supports full parity for IP4 and IPv6, advanced VRF assignment, automatic hierarchy formation, and much more.</p> <p></p>"},{"location":"Features/IPAM/#ip-hierarchy","title":"IP Hierarchy","text":"<p>NetMon employs several object types to represent a hierarchy of IP resources:</p> <ul> <li>Aggregate\u00a0- A prefix which represents the root of an addressing hierarchy. This is typically a large swath of public or private address space allocated for use by your organization. Each aggregate is assigned to an authoritative RIR.</li> <li>Prefix\u00a0- A subnet defined within an aggregate. Prefixes extend the hierarchy by nesting within one another. (For example, 192.168.123.0/24 will appear within 192.168.0.0/16.) Each prefix can be assigned a functional role as well as an operational status.</li> <li>IP Range\u00a0- An arbitrary range of individual IP addresses within a prefix, all sharing the same mask. Ranges are commonly affiliated with DHCP scopes, but can be used for any similar purpose.</li> <li>IP Address\u00a0- An individual IP address along with its subnet mask, automatically arranged beneath its parent prefix.</li> </ul> <p>Automatic Hierarchies</p> <p>IP objects in NetMon never need to be manually assigned to the parent objects. The construction of hierarchies is handled automatically by the application according to the inherent rules of IP addressing.</p> <p>An example hierarchy might look like this:</p> <ul> <li>100.64.0.0/10 (aggregate)</li> <li>100.64.0.0/20 (prefix)</li> <li>100.64.16.0/20 (prefix)<ul> <li>100.64.16.0/24 (prefix)</li> <li>100.64.16.1/24 (address)</li> <li>100.64.16.2/24 (address)</li> <li>100.64.16.3/24 (address)</li> <li>100.64.19.0/24 (prefix)</li> </ul> </li> <li>100.64.32.0/20 (prefix)<ul> <li>100.64.32.1/24 (address)</li> <li>100.64.32.10-99/24 (range)</li> </ul> </li> </ul>"},{"location":"Features/IPAM/#utilization-stats","title":"Utilization Stats","text":"<p>The utilization rate for each prefix is calculated automatically depending on its status.\u00a0Container\u00a0prefixes are those which house child prefixes; their utilization rate is determined based on how much of their available IP space is consumed by child prefixes. The utilization rate for any other type of prefix is determined by the aggregate usage of any child IP addresses and/or ranges defined.</p> <p>Similarly, utilization rates for aggregates is determined based on the space consumed by their child prefixes.</p>"},{"location":"Features/IPAM/#vrf-tracking","title":"VRF Tracking","text":"<p>NetMon supports the modeling of discrete virtual routing and forwarding (VRF) instances to represent multiple routing tables, including those with overlapping address space. Each type of IP object within an aggregate - prefix, IP range, and IP address - can be assigned to a particular VRF. Consequently, each VRF maintains its own isolated IP hierarchy. This makes it very easy to track overlapping IP space.</p> <p>VRF modeling in NetMon very closely follows what you find in real-world network configurations, with each VRF assigned a standards-compliant route distinguisher. You can even create route targets to manage the import and export of routing information among VRFs.</p> <p>Enforcing Unique IP Space</p> <p>Each VRF can be independently configured to permit or prohibit duplicate IP objects. For example, a VRF which has been configured to enforce unique IP space will not allow the creation of two 192.0.2.0/24 prefixes. The ability to toggle this restriction per VRF affords the user maximum flexibility in modeling their IP space.</p>"},{"location":"Features/IPAM/#as-numbers","title":"AS Numbers","text":"<p>An often overlooked component of IPAM, NetMon also tracks autonomous system (AS) numbers and their assignment to sites. Both 16- and 32-bit AS numbers are supported, and like aggregates each ASN is assigned to an authoritative RIR.</p>"},{"location":"Features/IPAM/#service-mapping","title":"Service Mapping","text":"<p>NetMon models network applications as discrete service objects associated with devices and/or virtual machines, and optionally with specific IP addresses attached to those parent objects. These can be used to catalog the applications running on your network for reference by other objects or integrated tools.</p> <p>To model services in NetMon, begin by creating a service template defining the name, protocol, and port number(s) on which the service listens. This template can then be easily instantiated to \"attach\" new services to a device or virtual machine. It's also possible to create new services by hand, without a template, however this approach can be tedious.</p>"}]}